// Package argon2 implements simple password hashing and verification using
// golang.org/x/crypto/argon2. It supports the Argon2id variant only and
// provides sensible and secure defaults for password hashing.
//
// A hash can be generated by calling [Hash] with a password, which returns a
// PHC-formatted string that can be stored in a database. Later, a password can
// be verified against the hash using [Verify].
//
// The default parameters are m=47104, t=1, and p=1 (which are recommended by
// the OWASP Password Storage Cheat Sheet), using a 16-byte salt and 32-byte
// key. For other use cases, one can customize the parameters by using [NewHash]
// to create an Argon2 instance with the desired parameters.
package argon2

import (
	"bytes"
	"crypto/rand"
	"crypto/subtle"
	"encoding/base64"
	"errors"
	"fmt"
	"strconv"

	"golang.org/x/crypto/argon2"
)

var b64 = base64.RawStdEncoding

var debug = false

func debugf(format string, args ...any) {
	if debug {
		fmt.Printf("argon2: "+format, args...)
	}
}

var (
	ErrInvalidHash = errors.New("invalid hash format or parameters")
	ErrInvalidType = errors.New("invalid hash type (only argon2id is supported)")
)

// An argon2id holds the Argon2id parameters for hashing.
type argon2id struct {
	time    uint32
	memory  uint32
	threads uint8
	keyLen  uint32
	saltLen uint32
}

// Default parameters for Argon2id, suitable for password hashing.
const (
	defaultTime    = 1
	defaultMemory  = 47104 // 46 MiB
	defaultThreads = 1
	defaultSaltLen = 16
	defaultKeyLen  = 32
)

// New creates a new Argon2 instance with default parameters, suitable for
// hashing passwords.
//
// The default parameters are:
//   - time: 1
//   - memory: 47104 (46 MiB)
//   - parallelism: 1
//   - salt length: 16 bytes
//   - key length: 32 bytes
func New() argon2id {
	return argon2id{
		time:    defaultTime,
		memory:  defaultMemory,
		threads: defaultThreads,
		saltLen: defaultSaltLen,
		keyLen:  defaultKeyLen,
	}
}

// NewHash creates a new Argon2 instance with the specified parameters. Consult
// the [OWASP Password Storage Cheat Sheet] when choosing parameters if unsure.
//
// Consider using the default parameters (via [New] or [Hash]) for password hashing.
//
// [OWASP Password Storage Cheat Sheet]: https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
func NewHash(time, memory uint32, threads uint8, saltLen, keyLen uint32) argon2id {
	return argon2id{
		time:    time,
		memory:  memory,
		threads: threads,
		saltLen: saltLen,
		keyLen:  keyLen,
	}
}

// Hash generates and encodes a hash for the given password using the Argon2
// parameters of this instance. The salt is generated using cryptographically
// secure random bytes.
func (h argon2id) Hash(password []byte) []byte {
	salt := make([]byte, h.saltLen)
	rand.Read(salt)
	key := argon2.IDKey(password, salt, h.time, h.memory, h.threads, h.keyLen)
	return h.formatHash(salt, key)
}

// formatHash formats the hash as a string in PHC format.
//
//	$argon2id$v={version}$m={memory}$t={time}$p={threads}${b64_salt}${b64_key}
func (h argon2id) formatHash(salt, key []byte) []byte {
	b64Salt := b64.EncodeToString(salt)
	b64Hash := b64.EncodeToString(key)
	return fmt.Appendf(nil, "$argon2id$v=%d$m=%d,t=%d,p=%d$%s$%s", argon2.Version, h.memory, h.time, h.threads, b64Salt, b64Hash)
}

// Parse parses the PHC-formatted argon2id hash and returns its parameters, salt, and key.
func Parse(hash []byte) (h argon2id, salt []byte, key []byte, err error) {
	parts := bytes.Split(hash, []byte("$"))
	if len(parts) != 6 {
		debugf("invalid hash format: %q", hash)
		err = ErrInvalidHash
		return
	}

	if string(parts[1]) != "argon2id" {
		debugf("invalid hash type: %q", hash)
		err = ErrInvalidType
		return
	}

	ver, err := strconv.Atoi(string(parts[2][2:]))
	if err != nil || ver != argon2.Version {
		debugf("invalid hash version: %q", hash)
		err = ErrInvalidHash
		return
	}

	n, err := fmt.Sscanf(string(parts[3]), "m=%d,t=%d,p=%d", &h.memory, &h.time, &h.threads)
	if n != 3 || err != nil {
		debugf("invalid hash parameters: %q", hash)
		err = ErrInvalidHash
		return
	}

	salt, err = b64.DecodeString(string(parts[4]))
	if err != nil {
		debugf("invalid hash salt: %q", hash)
		err = ErrInvalidHash
		return
	}
	key, err = b64.DecodeString(string(parts[5]))
	if err != nil {
		debugf("invalid hash key: %q", hash)
		err = ErrInvalidHash
		return
	}

	h.keyLen = uint32(len(key))
	h.saltLen = uint32(len(salt))

	return
}

// Hash generates a hash for the given password using the default parameters and
// returns a PHC-formatted string representing the hash.
func Hash(password []byte) []byte {
	return New().Hash(password)
}

// Verify verifies the given password against the PHC-formatted argon2id hash.
// It returns true if the password matches the hash and false if the hash is
// invalid or the password does not match.
func Verify(hash, password []byte) bool {
	h, salt, key, err := Parse(hash)
	if err != nil {
		return false
	}
	return subtle.ConstantTimeCompare(argon2.IDKey(password, salt, h.time, h.memory, h.threads, h.keyLen), key) == 1
}
